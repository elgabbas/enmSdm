% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geoThin.r
\name{geoThin}
\alias{geoThin}
\title{Thin geographic points (mostly) deterministically}
\usage{
geoThin(x, minDist, longLat = NULL, distFunct = NULL,
  verbose = FALSE, ...)
}
\arguments{
\item{x}{Data frame, matrix, SpatialPoints, or SpatialPointsDataFrame object.}

\item{minDist}{Numeric. Minimum distance needed between points to retain them. Points falling < this distance will be discarded. If \code{distFunct} is \code{distGeo} then this should be in the same units as \code{f} (see \code{link[geosphere]{distGeo}} and related "\code{dist}" functions).}

\item{longLat}{Two-element character list \emph{or} two-element integer list. If \code{x} is a data frame then this should be a character list specifiying the names of the fields in \code{x} \emph{or} a two-element list of integers that correspond to longitude and latitude (in that order). For example, \code{c('long', 'lat')} or \code{c(1, 2)}. If \code{x} is a matrix then this is a two-element list indicating the column numbers in \code{x} that represent longitude and latitude (for example, \code{c(1, 2)}). If \code{x} is a \code{SpatialPoints} or a \code{SpatialPointsDataFrame}  object then this argument is ignored.}

\item{distFunct}{Either a function or \code{NULL}. If \code{NULL} then \code{\link[geosphere]{distGeo}} is used to calculate distances.  More accurate distances can be obtained by using other functions (see \code{\link[geosphere]{distHaversine}} and references therein). Alternatively, a custom function can be used so long as its first argument is a 2-column numeric matrix with one row for the x- and y-coordinates of a single point and its second argument is a two-column numeric matrix with one or more rows of other points.}

\item{verbose}{Logical. If \code{TRUE} then display progress.}

\item{...}{Arguments to pass to \code{distFunct}.}
}
\value{
Object of class \code{x}.
}
\description{
This function thins geographic points such that none have nearest neighbors closer than some user-specified distance. The results are almost deterministic (see Details).
}
\details{
The procedure for removing points is as follows:
\itemize{
	\item Find points with largest number of neighbors (< \code{minDist} away). If just one such point exists, remove it, but if there is more than one then...
	\item Of these find the points with the closest neighbor within \code{minDist}. If just one such point exists, remove it, but if there is more than one then...
	\item Of these find the point that is closest to the centroid of all non-removed points. If just one such point exists, remove it, but if there is more than one...
	\item Of these find the point that has the smallest median distance to all points (even if > \code{minDist}). If just one such point exists, remove it, but if there is more than one then...
	\item Of these randomly select a point and remove it.
	\item Repeat.
}
Thus the results are deterministic up to the last tie-breaking step.
}
\examples{
# example using data frame
x <- data.frame(long=c(-90.1, -90.1, -90.15, -90.17, -90.2, -89),
   lat=c(38, 38, 38, 38, 38, 38), point=letters[1:6])
x
geoThin(x, minDist=500, longLat=1:2, verbose=TRUE)
geoThin(x, minDist=5000, longLat=c(1, 2), verbose=TRUE)

# example of potential randomness
set.seed(111)
geoThin(x, minDist=1000, longLat=c(1, 2))
geoThin(x, minDist=1000, longLat=c(1, 2))
geoThin(x, minDist=1000, longLat=c(1, 2))

# example using SpatialPointsDataFrame
data(lemurs)
fulvus <- lemurs[lemurs$species == 'Eulemur fulvus', c('longitude', 'latitude')]
fulvus <- sp::SpatialPointsDataFrame(
		fulvus,
		data=fulvus,
		proj4string=getCRS('wgs84', TRUE)
)

data(mad0)
sp::plot(mad0, main='Madagascar')
points(fulvus, col='red')
thinned <- geoThin(fulvus, 50000)
points(thinned, pch=16)
legend('topright', legend=c('retained', 'discarded'),
col=c('black', 'red'), pch=c(16, 1))

# test to see function works when no points need removed
thinned <- geoThin(fulvus, 200, verbose=TRUE)
sp::plot(mad0, main='Madagascar')
points(fulvus, col='red')
points(thinned, pch=16)
legend('topright', legend=c('retained', 'discarded'),
col=c('black', 'red'), pch=c(16, 1))
}
\seealso{
\code{\link{geoThinApprox}}
}
